# -*- coding: utf-8 -*-
"""RandForrest_SalesPrediction-DZ.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/19EjFc0V5xAZwglBOkb1TZTs45PdkatnR
"""

from dateutil.parser import parse 
import matplotlib as mpl
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
import pandas as pd
plt.rcParams.update({'figure.figsize': (10, 7), 'figure.dpi': 120})
import statsmodels.api as sm
from statsmodels.formula.api import ols
from sklearn.model_selection import train_test_split
import plotly.express as px
from numpy import asarray
from pandas import read_csv
from pandas import DataFrame
from pandas import concat
from sklearn.ensemble import RandomForestRegressor

# transform a time series dataset into a supervised learning dataset
def basic(string):
	def series_to_supervised(data, n_in=1, n_out=1, dropnan=True):
		n_vars = 1 if type(data) is list else data.shape[1]
		df = DataFrame(data)
		cols = list()
		# input sequence (t-n, ... t-1)
		for i in range(n_in, 0, -1):
			cols.append(df.shift(i))
		# forecast sequence (t, t+1, ... t+n)
		for i in range(0, n_out):
			cols.append(df.shift(-i))
		# put it all together
		agg = concat(cols, axis=1)
		# drop rows with NaN values
		if dropnan:
			agg.dropna(inplace=True)
		return agg.values

	# load the dataset
	series = pd.read_excel(r'PrimarySales_DZ.xlsx')
	series= series.loc[series['Product'] == string]
	series = series.drop('Product', axis=1)

	bins=[]

	for i in range(0,800000,100):
		bins.append(i)

	bins[0]=-1
	bins

	label=[]

	for j in range(1,8000):
		label.append(j)



	series['Count']= pd.cut(series['Count'],bins,labels=label)

	values = series.values

	# transform the time series data into supervised learning
	train = series_to_supervised(values, n_in=12)

	# split into input and output columns
	trainX, trainy = train[:, :-3], train[:, -1]
	# fit model
	model = RandomForestRegressor(n_estimators=3000)
	model.fit(trainX, trainy)
	# construct an input for a new prediction
	row = values[-12:].flatten()
	original=values[-12:]

	
	y=[]
	i=0
	for i in range(12):
	
		row=row[-36:]

		# make a one-step prediction

		yhat = model.predict(asarray([row]))

		if(row[34]==12):
			newy=row[33]+1
			newm=1

		else:
			newy=row[33]
			newm=row[34]+1

		newarr=[newy,newm,int(yhat[0])]
		print(row)
		row = np.append (row, newarr)
		i=i+1
		y=np.append(y,yhat)
		y=y.tolist()

		text=""

		for s in y:
			text+=str(int(s)*100)+"  ||  "
		text+=" DZ"
	return text
	#print('Input:\n %s \n\n Prediction for next month: %.f DZ' % (original, round(yhat[0]*100,-2)))

